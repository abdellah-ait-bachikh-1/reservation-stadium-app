// scripts/generate-i18n.ts
import fs from "fs";
import path from "path";

const ROOT = process.cwd();
const MESSAGES_DIR = path.join(ROOT, "messages");
const TYPES_FILE = path.join(ROOT, "types", "i18n.d.ts");
const UTILS_FILE = path.join(ROOT, "utils", "i18n.ts");

/* ---------------- Flatten keys recursively ---------------- */
function flattenKeys(obj: any, prefix = ""): string[] {
  const keys: string[] = [];
  function recurse(o: any, path: string) {
    if (typeof o === "string") {
      keys.push(path);
      return;
    }
    if (typeof o === "object" && o !== null) {
      for (const [k, v] of Object.entries(o)) {
        const newPath = path ? `${path}.${k}` : k;
        recurse(v, newPath);
      }
    }
  }
  recurse(obj, prefix);
  return keys;
}

/* ---------------- Build namespace map ---------------- */
function buildNamespaceMap(obj: any, prefix = ""): Record<string, string[]> {
  const map: Record<string, string[]> = {};
  function recurse(o: any, path: string) {
    if (typeof o !== "object" || o === null) return;

    const directKeys = Object.keys(o).filter(k => k);
    if (directKeys.length) map[path || "root"] = directKeys;

    for (const [k, v] of Object.entries(o)) {
      const newPath = path ? `${path}.${k}` : k;
      recurse(v, newPath);
    }
  }
  recurse(obj, prefix);
  return map;
}

/* ---------------- Load all JSON files ---------------- */
function loadMessages() {
  const files = fs.readdirSync(MESSAGES_DIR).filter(f => f.endsWith(".json"));
  const allKeys = new Set<string>();
  const fullNamespaceMap: Record<string, string[]> = {};

  for (const file of files) {
    const json = JSON.parse(fs.readFileSync(path.join(MESSAGES_DIR, file), "utf-8"));
    flattenKeys(json).forEach(k => allKeys.add(k));
    Object.assign(fullNamespaceMap, buildNamespaceMap(json));
  }

  return {
    keys: Array.from(allKeys).sort(),
    fullNamespaces: fullNamespaceMap,
  };
}

const { keys, fullNamespaces } = loadMessages();

/* ---------------- Generate TypeScript types ---------------- */
const typesContent = `
// ⚠️ AUTO-GENERATED — DO NOT EDIT
// Generated by scripts/generate-i18n.ts

/* ---------------- Translation keys ---------------- */
export type TranslationKey =
${keys.map(k => `    | '${k}'`).join("\n")};

export type AllTranslationKeys = TranslationKey;

export const _TranslationNamespaces = ${JSON.stringify(fullNamespaces, null, 2)} as const;

export type TranslationNamespace = keyof typeof _TranslationNamespaces;

`;

/* ---------------- Generate utils.ts ---------------- */
const utilsContent = `
// ⚠️ AUTO-GENERATED — DO NOT EDIT
// Generated by scripts/generate-i18n.ts

import { useTranslations } from "next-intl";
import { getTranslations } from "next-intl/server";
import { AllTranslationKeys } from "@/types/i18n";

/* ---------------- CLIENT ---------------- */
export function useTypedTranslations(): (key: AllTranslationKeys, values?: Record<string, any>) => string {
  const t = useTranslations();
  return ((key: AllTranslationKeys, values?: Parameters<typeof t>[1]) => t(key, values)) as
    (key: AllTranslationKeys, values?: Parameters<typeof t>[1]) => string;
}

/* ---------------- SERVER ---------------- */
export async function getTypedTranslations(): Promise<(key: AllTranslationKeys, values?: Record<string, any>) => string> {
  const t = await getTranslations();
  return ((key: AllTranslationKeys, values?: Parameters<typeof t>[1]) => t(key, values)) as
    (key: AllTranslationKeys, values?: Parameters<typeof t>[1]) => string;
}
`;

/* ---------------- Write files ---------------- */
fs.mkdirSync(path.dirname(TYPES_FILE), { recursive: true });
fs.mkdirSync(path.dirname(UTILS_FILE), { recursive: true });

fs.writeFileSync(TYPES_FILE, typesContent.trim() + "\n");
fs.writeFileSync(UTILS_FILE, utilsContent.trim() + "\n");

console.log("✅ i18n types & utils generated with full autocomplete in t('')");
